package dsdl

import (
	"fmt"
	"log"
	"os"
	"path"
	"time"

	"github.com/davidmanzanares/dsd/types"
)

// RunConf is the Runner's configuration
type RunConf struct {
	Args      []string
	HotReload bool
	OnSuccess RunReaction
	OnFailure RunReaction
	Polling   time.Duration
}

// DefaultPolling for Run when RunConf.Polling is set to the zero time.Duration
const DefaultPolling = 5 * time.Second

// RunReaction is the action to take when the deployed application exits
type RunReaction int

const (
	// Exit will stop the Runner's goroutine, returning "Stopped" to WaitForEvent()
	Exit RunReaction = iota
	// Wait will wait for future update (deploys), which will be started
	Wait
	// Restart will restart the application inmediatly
	Restart
)

// Runner manages the download, execution and updating process of a deployed application
type Runner struct {
	events   chan RunEvent
	commands chan string

	conf           RunConf
	provider       types.Provider
	currentVersion types.Version
	appExe         string
	spawned        *os.Process
	exit           chan exitType
}
type exitType struct {
	code int
	v    types.Version
}

// RunEventType is the type of events generated by Runner
type RunEventType int

const (
	// AppStarted events are sent when the application process gets started
	AppStarted RunEventType = iota
	// AppExit events are sent when the application process ends without being interrupted/killed for hotreloading updates
	AppExit
	// Stopped events are sent when the runner ends its execution, this is controlled by the OnSuccess/OnFailure properties of RunConf
	Stopped
)

// RunEvent is an event generated by the Runner
// Version is only valid for AppStarted events
// ExitCode is only valid for Stopped events
type RunEvent struct {
	Type     RunEventType
	Version  types.Version
	ExitCode int
	Reason   string
}

func (e RunEvent) String() string {
	if e.Type == AppStarted {
		return fmt.Sprintf("AppStarted{Version: %s Reason: %s}", e.Version, e.Reason)
	} else if e.Type == AppExit {
		return fmt.Sprintf("AppExit{Version: %s, ExitCode: %d}", e.Version, e.ExitCode)
	} else if e.Type == Stopped {
		return "Stopped"
	} else {
		panic(e)
	}
}

// Run runs a deployed application on service with a configuration
func Run(service string, conf RunConf) (*Runner, error) {
	p, err := getProviderFromService(service)
	if err != nil {
		return nil, err
	}

	if conf.Polling == 0 {
		conf.Polling = DefaultPolling
	}

	r := &Runner{events: make(chan RunEvent, 10), commands: make(chan string, 10), provider: p, conf: conf}
	go r.manager()
	r.commands <- "update"
	return r, nil
}

// WaitForEvent waits for the generation of the next RunEvent
func (r *Runner) WaitForEvent() RunEvent {
	ev, ok := <-r.events
	if !ok {
		return RunEvent{Type: Stopped}
	}
	return ev
}

// Stop stops the current runner, interrupting/killing the application
func (r *Runner) Stop() {
	r.commands <- "stop"
}

func (r *Runner) manager() {
	defer close(r.events)
	for {
		select {
		case exit := <-r.exit:
			r.events <- RunEvent{Type: AppExit, Version: exit.v, ExitCode: exit.code}
			r.spawned = nil
			if exit.code == 0 {
				if r.conf.OnSuccess == Restart {
					r.run("restarted on success")
				} else if r.conf.OnSuccess == Exit {
					return
				} else {
					r.exit = nil
				}
			} else {
				if r.conf.OnFailure == Restart {
					r.run("restarted on failure")
				} else if r.conf.OnFailure == Exit {
					return
				} else {
					r.exit = nil
				}
			}
		case <-time.After(r.conf.Polling):
			if r.conf.HotReload || r.spawned == nil {
				r.update()
			}
		case cmd := <-r.commands:
			if cmd == "update" {
				r.update()
				continue
			} else if cmd == "stop" {
				r.kill()
				return
			} else {
				panic(fmt.Sprint("Unkown command:", cmd))
			}
		}
	}
}
func (r *Runner) kill() {
	if r.spawned != nil {
		// TODO call Interrupt first
		//r.spawned.Signal(os.Interrupt)
		//time.Sleep(time.Second)

		err := kill(r.spawned)
		if err != nil {
			log.Println(err)
		}

		r.spawned = nil
		for range r.exit {
		}
	}
}

func (r *Runner) update() {
	v, err := r.provider.GetCurrentVersion()
	if err != nil {
		log.Println(err)
		return
	}
	if v == r.currentVersion {
		return
	}
	exe, err := download(r.provider, v)
	if err != nil {
		log.Println(err)
		return
	}
	if exe == "" {
		log.Println("Error, executable not found")
		return
	}
	r.appExe = exe
	r.currentVersion = v
	r.run("update")
}

func (r *Runner) run(reason string) {
	r.kill()
	wd, err := os.Getwd()
	if err != nil {
		log.Println(err)
		return
	}
	// TODO windows should kill the process tree (grand children too)
	r.spawned, err = os.StartProcess(path.Join(wd, r.appExe), append([]string{r.appExe}, r.conf.Args...),
		&os.ProcAttr{
			Dir:   path.Dir(r.appExe),
			Files: []*os.File{os.Stdin, os.Stdout, os.Stderr},
			Sys:   runSysProcAttr()})
	if err != nil {
		log.Println(err)
		return
	}
	r.events <- RunEvent{Type: AppStarted, Version: r.currentVersion, Reason: reason}
	r.exit = make(chan exitType)
	go func(spawned *os.Process, v types.Version, exitCh chan exitType) {
		state, _ := spawned.Wait()
		exitCh <- exitType{code: state.ExitCode(), v: v}
		close(exitCh)
	}(r.spawned, r.currentVersion, r.exit)
}
